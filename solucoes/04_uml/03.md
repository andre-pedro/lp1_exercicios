# Problema

Considera o diagrama UML em baixo, e depois indica, justificando, quais das
seguintes instruções são válidas e quais são inválidas. As instruções são
independentes umas das outras, e naquelas que não implicam criação de objetos
presume-se que o(s) objeto(s) em questão já foram instanciados. Considera-se
que todas as instruções ocorrem fora das classes presentes no diagrama.

![uml03](https://user-images.githubusercontent.com/3018963/39089164-7c657fc0-45b8-11e8-9f73-a20edb1654c5.png)

* `Animal animal = new Dog();`
* `Cat cat = new Dog();`
* `Cat cat = new Animal();`
* `a.Bark(); // 'a' é uma instância de Animal`
* `dog.Eat(); // 'dog' é uma instância de Dog`
* `float y = tareco.energy; // 'tareco' é uma instância de Cat`
* `Console.WriteLine(myCat.Name); // 'myCat' é uma instância de Cat`
* `bobi.energy = 123.4f; // 'bobi é uma instância de Dog'`
* `Dog pluto = new Animal();`
* `y.Meow(); // 'y' é uma instância de Cat`
* `beast.Bite(); // 'beast' é uma instância de Animal`
* `zz.Eat(); // 'zz' é uma instância de Cat`

# Soluções

## Solução 1:

* `Animal animal = new Dog();` - Verdadeiro, porque devido a `Animal` ser uma superclasse esta pode instanciar uma subclasse;
* `Cat cat = new Dog();` - Falso, pois `Cat` não herda da classe `Dog`, não podendo instanciar a instrução pretendida;
* `Cat cat = new Animal();` - Falso, porque `Animal` herda de `Cat` e não o contrário, como escrito na questão;
* `a.Bark(); // 'a' é uma instância de Animal` - Falso, porque `Bark()` é um método de `Dog` e não de `Animal`;
* `dog.Eat(); // 'dog' é uma instância de Dog` - Verdadeiro, `dog` pode usar o método `Eat()` devido à classe `Dog` herdar de `Animal`;
* `float y = tareco.energy; // 'tareco' é uma instância de Cat` - Verdadeiro, porque o método `Energy()` está presente em `Animal`. Como tal, `tareco` (estando presente 
em `Cat`, que herda de `Animal`), consegue usar `energy`;
* `Console.WriteLine(myCat.Name); // 'myCat' é uma instância de Cat` - Verdadeiro, pois está a ser pedido para ser impresso a propriedade `Name` de `myCat` (instância de Cat), e 
como a classe `Cat` herda de `Animal`, a instrução é válida;
* `bobi.energy = 123.4f; // 'bobi é uma instância de Dog'` - Verdadeiro, pois apesar de na classe `Dog` não existir a propriedade `energy`, como esta herda de `Animal` a instrução é válida; 
* `Dog pluto = new Animal();` - Falso, porque `Animal` herda de `Dog` e não o contrário, como escrito na questão;;
* `y.Meow(); // 'y' é uma instância de Cat` - Verdadeiro, porque se `y` é uma instância de Cat consegue usar o método `Meow()`;
* `beast.Bite(); // 'beast' é uma instância de Animal` - Falso, porque como `beast` é uma instância de `animal` este não consegue usar os métodos da classe `Dog`; 
* `zz.Eat(); // 'zz' é uma instância de Cat` - Verdadeiro, porque sendo `zz` uma instância de `Cat`, este herda o método `Eat()` da superclasse `Animal`;

*Solução proposta por [André Pedro](https://github.com/andre-pedro)*