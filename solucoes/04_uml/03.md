# Problema

Considera o diagrama UML em baixo, e depois indica, justificando, quais das
seguintes instruções são válidas e quais são inválidas. As instruções são
independentes umas das outras, e naquelas que não implicam criação de objetos
presume-se que o(s) objeto(s) em questão já foram instanciados. Considera-se
que todas as instruções ocorrem fora das classes presentes no diagrama.

![uml03](https://user-images.githubusercontent.com/3018963/39089164-7c657fc0-45b8-11e8-9f73-a20edb1654c5.png)

* `Animal animal = new Dog();`
* `Cat cat = new Dog();`
* `Cat cat = new Animal();`
* `a.Bark(); // 'a' é uma instância de Animal`
* `dog.Eat(); // 'dog' é uma instância de Dog`
* `float y = tareco.energy; // 'tareco' é uma instância de Cat`
* `Console.WriteLine(myCat.Name); // 'myCat' é uma instância de Cat`
* `bobi.energy = 123.4f; // 'bobi é uma instância de Dog'`
* `Dog pluto = new Animal();`
* `y.Meow(); // 'y' é uma instância de Cat`
* `beast.Bite(); // 'beast' é uma instância de Animal`
* `zz.Eat(); // 'zz' é uma instância de Cat`

# Soluções

## Solução 1:

* `Animal animal = new Dog();` - Verdadeiro, porque devido a `Animal` ser uma classe genérica esta pode instanciar uma subclasse;
* `Cat cat = new Dog();` - Falso, pois tanto `Cat` como `Dog` são subclasses, e como tal não podem instanciar de outras subclasses;
* `Cat cat = new Animal();` - Falso, porque `Animal` herda de `Cat` e não o contrário, como escrito na questão;
* `a.Bark(); // 'a' é uma instância de Animal` - Falso, porque `Bark()` é um método de `Dog` e não de `Animal`;
* `dog.Eat(); // 'dog' é uma instância de Dog` - Verdadeiro, `dog` pode usar o método `Eat()` devido à classe `Dog` herdar de `Animal`;
* `float y = tareco.energy; // 'tareco' é uma instância de Cat` - Verdadeiro, porque o método `Energy()` está presente em `Animal`. Como tal, `tareco` (estando presente 
em `Cat`, que herda de `Animal`), consegue usar `energy`;
* `Console.WriteLine(myCat.Name); // 'myCat' é uma instância de Cat` - Verdadeiro, pois está a ser pedido para ser impresso o nome do `myCat` (instância de Cat), e 
como a classe `Cat` herda de `Animal`, o método é válido;
* `bobi.energy = 123.4f; // 'bobi é uma instância de Dog'` - Verdadeiro, pois apesar de na classe `Dog` não existir `energy`, como esta herda de `Animal` o método é válido; 
* `Dog pluto = new Animal();` - Falso, porque `Animal` herda de `Dog` e não o contrário, como escrito na questão;;
* `y.Meow(); // 'y' é uma instância de Cat` - Verdadeiro, porque se `y` é uma instância de Cat consegue usar o método `Meow()`;
* `beast.Bite(); // 'beast' é uma instância de Animal` - Falso, porque como `beast` é uma instância de ``animal` este não consegue usar os métodos da classe `Dog`; 
* `zz.Eat(); // 'zz' é uma instância de Cat` - Verdadeiro, porque sendo `zz` uma instância de `Cat`, este herda o `Eat` da superclasse `Animal`;

*Solução proposta por [André Pedro](https://github.com/andre-pedro)*